---
layout: page
title: "Decompress"
assignment: "huffman"
---

##Intro
Similar to compression, it is possible to write the entire algorithm in one method, but it is easier to break down the problem and a few parts are easier to do with recursion. Your code will be easier to read and debug if broken up and you will not lose any points for engineering.  Use the test file from before to try compressing and decompressing a file or simply the junit tests.  Once these work, use a larger file (melville.txt is a good one) and use the compare tab to make sure the uncompressed and the decompressed versions are the same.  Decompression should go much faster than compression since by now you should have a better understanding of the Huffman coding algorithm.

##Rebuilding the Tree
First, check to make sure the `HUFF_NUMBER` is present at the beginning of the file using the `BitInputStream` and the `readBits()` method.  You should read `BITS_PER_INT` bits.  If the `HUFF_NUMBER` isn't there, throw a `HuffException` with an informative message.  Once that is verified, you can move on to reading the header with a recursive helper method.  First, read a single bit.  If the bit is a 0, then you are at an internal node and need to make two recursive calls to build the current node's two sub-trees.  Be sure to make the recursive calls in the right order so that your codes aren't flipped.  If the bit was instead a 1, then you need to read the next 9 bits to get the value of the character.  Create a new `HuffNode` with the value of the 9 bits you just read and weight of whatever you'd like.  The weight doesn't matter now since the entire structure of the tree is specified by the header.  If you wrote the header correctly, then this recursive process should terminate naturally at exactly the end of the header.  If instead you are encountering errors, check the write and read methods for the header for any minor mistakes.

##Decoding the Body
With a tree, all you have to do now is continue to decode characters until you reach the `PSEUDO_EOF` character.  With a while loop, read one bit at a time.  Depending on the value of that bit, move the current node to either the left or right sub-child.  Include a if-case check for the bit equaling -1, if a file was not compressed properly or there's an error in your decompress methods, then you may miss the `PSEUDO_EOF` and read all the way to the full end of the file.  If the current bit equals -1, throw a `HuffException` like before with the message "Problem with the `PSEUDO_EOF`" so that you will know where to begin debugging if the error should occur.  If the bit was valid and you move to a new node, check if it is a leaf.  If so, then check if the value of the node is the `PSEUDO_EOF`.  When you encounter the `PSEUDO_EOF`, you need to return so that you stop writing and reading bits.  For all other characters, write `BITS_PER_WORD` bits using the `BitOutputStream` with the value of the character stored in the node.  After writing the character, you also need to reset the current node pointer to the root of the tree.  By now you should have a fully working compress and decompress system which you can verify using the compare tab.  Once you are sure that your code works, move onto the analysis or check out the extra credit section.
